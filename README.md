# Антиплагиат

## В чем состоит решение?

Мой код предсказывает похожесть двух текстов используя логистическую регрессию. Используя библиотеку ast, из кода выделяются признаки, подробный список которых перечислен в классе Parser

Структура проекта выглядит следующим образом. В train.py мы считываем аргументы, после чего по данным путям к папкам files, plagiat1 и plagiat2 формируем датасет следующим образом для каждой пары файлов: если названия файлов одинаковы (а по итогу так обозначаются файл-оригинал и файл-фейк), то вероятность того, что одно решение заимствовано из другого равно единице. Иначе эта вероятность равна нулю. Пары берутся из папок files-plagiat1 и files-plagiat2 (один элемент пары берем из первой папки, другой из второй). Собственно, в compare.py мы подгружаем модель и даем предсказания.

## Особенность задачи и почему использована логистическая регрессия

Посмотрев на задачу мне в первую очередь пришла мысль о том, что в данной задаче требуется написать проверку кода на схожесть в общем виде. Что вещь достаточно сложная отчасти, ведь решения могут быть схожи по своей сути, ну вот делают они одно и то же, а на деле написаны разными людьми. Однако в данном случае специфика самой задачи делает её решение проще.

В данном нам датасете даны конкретные программы, которые делают конкретные вещи. Более того, любое преобразование данных программ воспринимается как списывание. В общем, есть мысль что программы сами по себе между собой разные, потому от нас не требуется во время сравнения понять, схожи ли программы потому, что они написаны разными людьми или потому, что они списаны. Вот, в этом суть.

Главная идея -- по двум переданным программам (с выделенными из них признаками) предсказывать вероятность их схожести через 0 и 1. Делать это будем с помощью логистической регрессии -- есть мысль, что все выделенные признаки +- одинаковы у программы-плагиата и оригинальной программы, что указывает на то, что выбранные данные линейно разделимы  и что для этого можно не использовать сильные методы (по типу деревьев решений и их ансамблей). Плюсом хочется реализовать что-то крутое и сделать это в короткий срок.

## Почему в репозитории есть что-то кроме compare.py, train.py и модели?

Во -- первых, так как задание максимально творческое, я попытался реализовать нужные мне вещи используя принципы ООП и в целом хороший тон написания кода.

Во -- вторых, декомпозиция решения на файлы дает а.) модульность и б.) удобство работы с отдельными блоками решения. Заметим, что в каждом отдельном файле (кроме compare.py и train.py) реализована отдельная структура, описанная классом и используемая в решении (парсер, модель, примитивы). В свою очередьь это дает возможность для их удобной замены и/или тестирования: удобно импортировать парсер из одного файла, а не подргужать весь файл и уже потом вытаскивать из него нужное. Также таким образом можно удобно работать над несколькими версиями какого-то блока из решения, например, в случае если они сильно отличаются.

## Какие признаки выбраны (и почему).

Главная идея -- если программы одинаковы, то они +- одинаковы во всем. Именно поэтому я пользуюсь выделением отдельных структур языка (условных операторов, циклов, классов, присваиваний), а также максимальной вложенностью.

Интерес вызывает несколько характеристик. Например, характеристика подсчета количества общих библиотек. Мотивация такого подсчета в том, что один и тот же код использует примерно одни и те же библиотеки для решения задачи, что естественно характеризует похожесть двух решений.

Также интересен подсчет похожести схожести набора переменных. Тут я пользуюсь следующим рассуждением: если код действительно списан, но при этом вор пытается сохранить осмысленность названий переменных, он вполне себе может незначительно менять названия переменных, при этом не меняя смысл. Потому важность играет насколько похожи названия переменных в среднем. Тут вступает в роль придуманная нами метрика: для каждого названия переменной из кода в первом файле берется наиболее похожее название из кода в втором файле, такой же подсчет повторяется для каждого названия переменной из второго файла. По полученной максимальной схожести берется среднее значение. Метрикой оценки схожести двух названий выбран алгоритм поиска Наибольшей Общей Подпоследовательности -- алгоритм, схожий подсчету расстояния Левенштейна, однако если в случае похожести двух переменных расстояние Левенштейна минимизируется, то длина НОП, наоборот, максимизируется. Данная метрика устойчива к расположению переменных в коде, она не требует большого вычислительного ресурса и благодаря структуре не зависит от расположения кодов при рассмотрении (симметрична).

Таким образом, анализ кода в целом работает быстро и считает объективные характеристики кода, по которым в том числе можно судить о его похожести.

## Достоинства решения

1. Само по себе решение в целом легковесно и не требует огромного числа вычислительных ресурсов (ну, разумеется, перебарщивать тоже не стоит, однако код также можно оптимизировать)
2. Благодаря разделению компонент на отдельные файлы реализована максимальная гибкость кода к изменению. Более того, каждую компоненту решения можно также гибко доработать внутри при желании. Реализована универсальность методов, в том же парсере вместо мелкого редактирования метода под одну задачу практически все методы используются не только для какой-то единой конкретной задачи. Разработаны примитивы, что явно использует многообразие возможностей языка.
3. Выбираемые признаки подобраны качественно, также как и модель :) (себя не похвалишь, никто не похвалит)
4. Простота решения и вследствии быстрая его реализация

## Что можно было бы доработать

1. Добавить больше инструментов с точки зрения машинного обучения (кросс-валидация, большее число выделяемых признаков, возможно, попробовать ансамбли логистических регрессий)

2. Добавить больше опций для парсера (вроде выделения конкретных признаков из кода), добавить больше опций для командной строки (выставка настроек для обучения модели машинного обучения через аргументы командной строки, то же самое касается парсера).

3. Придумать обертку красивую (написать приложение на фласке как пример, как и в целом предложить какой-то фронтенд)

## Что итого?

Я надеюсь вам понравится мое решение и вы получите удовольствие от его использования :3. Ну и надеюсь что я в свою очередь смогу попасть на трек глубокого обучения в Tinkoff Поколение.

## Ставьте лайки подписывайтесь на канал оставляйте комментарии всем удачи всем пока-пока

t.me/defineintlonglong
